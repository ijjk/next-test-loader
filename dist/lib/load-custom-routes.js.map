{"version":3,"sources":["../../lib/load-custom-routes.ts"],"names":["allowedStatusCodes","Set","allowedHasTypes","namedGroupsRegex","getRedirectStatus","route","statusCode","permanent","PERMANENT_REDIRECT_STATUS","TEMPORARY_REDIRECT_STATUS","normalizeRouteRegex","regex","replace","modifyRouteRegex","restrictedPaths","map","path","join","checkRedirect","invalidParts","hadInvalidStatus","has","push","checkHeader","Array","isArray","headers","header","key","value","tryParsePath","handleUrl","result","routePath","parsedDestination","pathname","hash","tokens","pathToRegexp","parse","tokensToRegexp","err","errMatches","message","match","position","parseInt","console","error","fill","checkCustomRoutes","routes","type","process","exit","numInvalidRoutes","hadInvalidHas","allowedKeys","add","JSON","stringify","basePath","destination","startsWith","source","keys","Object","invalidKeys","filter","locale","invalidHasItems","hasItem","invalidHasParts","length","itemStr","_route","sourceTokens","hasSegments","matchAll","unnamedInDest","token","name","unnamedIndex","RegExp","size","destTokens","destinationParseFailed","sourceSegments","item","Boolean","invalidDestSegments","hasInvalidKeys","hasInvalidParts","processRoutes","config","_routes","newRoutes","defaultLocales","i18n","domains","defaultLocale","base","http","domain","r","srcBasePath","isExternal","destBasePath","forEach","locales","trailingSlash","loadRedirects","redirects","loadRewrites","rewrites","beforeFiles","afterFiles","fallback","_rewrites","every","loadHeaders","loadCustomRoutes","Promise","all","unshift","undefined","internal"],"mappings":"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","sourcesContent":["import { parse as parseUrl } from 'url'\nimport { NextConfig } from '../server/config'\nimport * as pathToRegexp from 'next/dist/compiled/path-to-regexp'\nimport escapeStringRegexp from 'next/dist/compiled/escape-string-regexp'\nimport {\n  PERMANENT_REDIRECT_STATUS,\n  TEMPORARY_REDIRECT_STATUS,\n} from '../shared/lib/constants'\n\nexport type RouteHas =\n  | {\n      type: 'header' | 'query' | 'cookie'\n      key: string\n      value?: string\n    }\n  | {\n      type: 'host'\n      key?: undefined\n      value: string\n    }\n\nexport type Rewrite = {\n  source: string\n  destination: string\n  basePath?: false\n  locale?: false\n  has?: RouteHas[]\n}\n\nexport type Header = {\n  source: string\n  basePath?: false\n  locale?: false\n  headers: Array<{ key: string; value: string }>\n  has?: RouteHas[]\n}\n\n// internal type used for validation (not user facing)\nexport type Redirect = {\n  source: string\n  destination: string\n  basePath?: false\n  locale?: false\n  has?: RouteHas[]\n  statusCode?: number\n  permanent?: boolean\n}\n\nexport const allowedStatusCodes = new Set([301, 302, 303, 307, 308])\nconst allowedHasTypes = new Set(['header', 'cookie', 'query', 'host'])\nconst namedGroupsRegex = /\\(\\?<([a-zA-Z][a-zA-Z0-9]*)>/g\n\nexport function getRedirectStatus(route: {\n  statusCode?: number\n  permanent?: boolean\n}): number {\n  return (\n    route.statusCode ||\n    (route.permanent ? PERMANENT_REDIRECT_STATUS : TEMPORARY_REDIRECT_STATUS)\n  )\n}\n\nexport function normalizeRouteRegex(regex: string) {\n  // clean up un-necessary escaping from regex.source which turns / into \\\\/\n  return regex.replace(/\\\\\\//g, '/')\n}\n\n// for redirects we restrict matching /_next and for all routes\n// we add an optional trailing slash at the end for easier\n// configuring between trailingSlash: true/false\nexport function modifyRouteRegex(regex: string, restrictedPaths?: string[]) {\n  if (restrictedPaths) {\n    regex = regex.replace(\n      /\\^/,\n      `^(?!${restrictedPaths\n        .map((path) => path.replace(/\\//g, '\\\\/'))\n        .join('|')})`\n    )\n  }\n  regex = regex.replace(/\\$$/, '(?:\\\\/)?$')\n  return regex\n}\n\nfunction checkRedirect(\n  route: Redirect\n): { invalidParts: string[]; hadInvalidStatus: boolean } {\n  const invalidParts: string[] = []\n  let hadInvalidStatus: boolean = false\n\n  if (route.statusCode && !allowedStatusCodes.has(route.statusCode)) {\n    hadInvalidStatus = true\n    invalidParts.push(`\\`statusCode\\` is not undefined or valid statusCode`)\n  }\n  if (typeof route.permanent !== 'boolean' && !route.statusCode) {\n    invalidParts.push(`\\`permanent\\` is not set to \\`true\\` or \\`false\\``)\n  }\n\n  return {\n    invalidParts,\n    hadInvalidStatus,\n  }\n}\n\nfunction checkHeader(route: Header): string[] {\n  const invalidParts: string[] = []\n\n  if (!Array.isArray(route.headers)) {\n    invalidParts.push('`headers` field must be an array')\n  } else {\n    for (const header of route.headers) {\n      if (!header || typeof header !== 'object') {\n        invalidParts.push(\n          \"`headers` items must be object with { key: '', value: '' }\"\n        )\n        break\n      }\n      if (typeof header.key !== 'string') {\n        invalidParts.push('`key` in header item must be string')\n        break\n      }\n      if (typeof header.value !== 'string') {\n        invalidParts.push('`value` in header item must be string')\n        break\n      }\n    }\n  }\n  return invalidParts\n}\n\ntype ParseAttemptResult = {\n  error?: boolean\n  tokens?: pathToRegexp.Token[]\n}\n\nfunction tryParsePath(route: string, handleUrl?: boolean): ParseAttemptResult {\n  const result: ParseAttemptResult = {}\n  let routePath = route\n\n  try {\n    if (handleUrl) {\n      const parsedDestination = parseUrl(route, true)\n      routePath = `${parsedDestination.pathname!}${\n        parsedDestination.hash || ''\n      }`\n    }\n\n    // Make sure we can parse the source properly\n    result.tokens = pathToRegexp.parse(routePath)\n    pathToRegexp.tokensToRegexp(result.tokens)\n  } catch (err) {\n    // If there is an error show our error link but still show original error or a formatted one if we can\n    const errMatches = err.message.match(/at (\\d{0,})/)\n\n    if (errMatches) {\n      const position = parseInt(errMatches[1], 10)\n      console.error(\n        `\\nError parsing \\`${route}\\` ` +\n          `https://nextjs.org/docs/messages/invalid-route-source\\n` +\n          `Reason: ${err.message}\\n\\n` +\n          `  ${routePath}\\n` +\n          `  ${new Array(position).fill(' ').join('')}^\\n`\n      )\n    } else {\n      console.error(\n        `\\nError parsing ${route} https://nextjs.org/docs/messages/invalid-route-source`,\n        err\n      )\n    }\n    result.error = true\n  }\n\n  return result\n}\n\nexport type RouteType = 'rewrite' | 'redirect' | 'header'\n\nfunction checkCustomRoutes(\n  routes: Redirect[] | Header[] | Rewrite[],\n  type: RouteType\n): void {\n  if (!Array.isArray(routes)) {\n    console.error(\n      `Error: ${type}s must return an array, received ${typeof routes}.\\n` +\n        `See here for more info: https://nextjs.org/docs/messages/routes-must-be-array`\n    )\n    process.exit(1)\n  }\n\n  let numInvalidRoutes = 0\n  let hadInvalidStatus = false\n  let hadInvalidHas = false\n\n  const allowedKeys = new Set<string>(['source', 'basePath', 'locale', 'has'])\n\n  if (type === 'rewrite') {\n    allowedKeys.add('destination')\n  }\n  if (type === 'redirect') {\n    allowedKeys.add('statusCode')\n    allowedKeys.add('permanent')\n    allowedKeys.add('destination')\n  }\n  if (type === 'header') {\n    allowedKeys.add('headers')\n  }\n\n  for (const route of routes) {\n    if (!route || typeof route !== 'object') {\n      console.error(\n        `The route ${JSON.stringify(\n          route\n        )} is not a valid object with \\`source\\` and \\`${\n          type === 'header' ? 'headers' : 'destination'\n        }\\``\n      )\n      numInvalidRoutes++\n      continue\n    }\n\n    if (\n      type === 'rewrite' &&\n      (route as Rewrite).basePath === false &&\n      !(\n        (route as Rewrite).destination.startsWith('http://') ||\n        (route as Rewrite).destination.startsWith('https://')\n      )\n    ) {\n      console.error(\n        `The route ${\n          (route as Rewrite).source\n        } rewrites urls outside of the basePath. Please use a destination that starts with \\`http://\\` or \\`https://\\` https://nextjs.org/docs/messages/invalid-external-rewrite`\n      )\n      numInvalidRoutes++\n      continue\n    }\n\n    const keys = Object.keys(route)\n    const invalidKeys = keys.filter((key) => !allowedKeys.has(key))\n    const invalidParts: string[] = []\n\n    if (typeof route.basePath !== 'undefined' && route.basePath !== false) {\n      invalidParts.push('`basePath` must be undefined or false')\n    }\n\n    if (typeof route.locale !== 'undefined' && route.locale !== false) {\n      invalidParts.push('`locale` must be undefined or false')\n    }\n\n    if (typeof route.has !== 'undefined' && !Array.isArray(route.has)) {\n      invalidParts.push('`has` must be undefined or valid has object')\n      hadInvalidHas = true\n    } else if (route.has) {\n      const invalidHasItems = []\n\n      for (const hasItem of route.has) {\n        let invalidHasParts = []\n\n        if (!allowedHasTypes.has(hasItem.type)) {\n          invalidHasParts.push(`invalid type \"${hasItem.type}\"`)\n        }\n        if (typeof hasItem.key !== 'string' && hasItem.type !== 'host') {\n          invalidHasParts.push(`invalid key \"${hasItem.key}\"`)\n        }\n        if (\n          typeof hasItem.value !== 'undefined' &&\n          typeof hasItem.value !== 'string'\n        ) {\n          invalidHasParts.push(`invalid value \"${hasItem.value}\"`)\n        }\n        if (typeof hasItem.value === 'undefined' && hasItem.type === 'host') {\n          invalidHasParts.push(`value is required for \"host\" type`)\n        }\n\n        if (invalidHasParts.length > 0) {\n          invalidHasItems.push(\n            `${invalidHasParts.join(', ')} for ${JSON.stringify(hasItem)}`\n          )\n        }\n      }\n\n      if (invalidHasItems.length > 0) {\n        hadInvalidHas = true\n        const itemStr = `item${invalidHasItems.length === 1 ? '' : 's'}`\n\n        console.error(\n          `Invalid \\`has\\` ${itemStr}:\\n` + invalidHasItems.join('\\n')\n        )\n        console.error()\n        invalidParts.push(`invalid \\`has\\` ${itemStr} found`)\n      }\n    }\n\n    if (!route.source) {\n      invalidParts.push('`source` is missing')\n    } else if (typeof route.source !== 'string') {\n      invalidParts.push('`source` is not a string')\n    } else if (!route.source.startsWith('/')) {\n      invalidParts.push('`source` does not start with /')\n    }\n\n    if (type === 'header') {\n      invalidParts.push(...checkHeader(route as Header))\n    } else {\n      let _route = route as Rewrite | Redirect\n      if (!_route.destination) {\n        invalidParts.push('`destination` is missing')\n      } else if (typeof _route.destination !== 'string') {\n        invalidParts.push('`destination` is not a string')\n      } else if (\n        type === 'rewrite' &&\n        !_route.destination.match(/^(\\/|https:\\/\\/|http:\\/\\/)/)\n      ) {\n        invalidParts.push(\n          '`destination` does not start with `/`, `http://`, or `https://`'\n        )\n      }\n    }\n\n    if (type === 'redirect') {\n      const result = checkRedirect(route as Redirect)\n      hadInvalidStatus = hadInvalidStatus || result.hadInvalidStatus\n      invalidParts.push(...result.invalidParts)\n    }\n\n    let sourceTokens: pathToRegexp.Token[] | undefined\n\n    if (typeof route.source === 'string' && route.source.startsWith('/')) {\n      // only show parse error if we didn't already show error\n      // for not being a string\n      const { tokens, error } = tryParsePath(route.source)\n\n      if (error) {\n        invalidParts.push('`source` parse failed')\n      }\n      sourceTokens = tokens\n    }\n    const hasSegments = new Set<string>()\n\n    if (route.has) {\n      for (const hasItem of route.has) {\n        if (!hasItem.value && hasItem.key) {\n          hasSegments.add(hasItem.key)\n        }\n\n        if (hasItem.value) {\n          for (const match of hasItem.value.matchAll(namedGroupsRegex)) {\n            if (match[1]) {\n              hasSegments.add(match[1])\n            }\n          }\n\n          if (hasItem.type === 'host') {\n            hasSegments.add('host')\n          }\n        }\n      }\n    }\n\n    // make sure no unnamed patterns are attempted to be used in the\n    // destination as this can cause confusion and is not allowed\n    if (typeof (route as Rewrite).destination === 'string') {\n      if (\n        (route as Rewrite).destination.startsWith('/') &&\n        Array.isArray(sourceTokens)\n      ) {\n        const unnamedInDest = new Set()\n\n        for (const token of sourceTokens) {\n          if (typeof token === 'object' && typeof token.name === 'number') {\n            const unnamedIndex = new RegExp(`:${token.name}(?!\\\\d)`)\n            if ((route as Rewrite).destination.match(unnamedIndex)) {\n              unnamedInDest.add(`:${token.name}`)\n            }\n          }\n        }\n\n        if (unnamedInDest.size > 0) {\n          invalidParts.push(\n            `\\`destination\\` has unnamed params ${[...unnamedInDest].join(\n              ', '\n            )}`\n          )\n        } else {\n          const {\n            tokens: destTokens,\n            error: destinationParseFailed,\n          } = tryParsePath((route as Rewrite).destination, true)\n\n          if (destinationParseFailed) {\n            invalidParts.push('`destination` parse failed')\n          } else {\n            const sourceSegments = new Set(\n              sourceTokens\n                .map((item) => typeof item === 'object' && item.name)\n                .filter(Boolean)\n            )\n            const invalidDestSegments = new Set()\n\n            for (const token of destTokens!) {\n              if (\n                typeof token === 'object' &&\n                !sourceSegments.has(token.name) &&\n                !hasSegments.has(token.name as string)\n              ) {\n                invalidDestSegments.add(token.name)\n              }\n            }\n\n            if (invalidDestSegments.size) {\n              invalidParts.push(\n                `\\`destination\\` has segments not in \\`source\\` or \\`has\\` (${[\n                  ...invalidDestSegments,\n                ].join(', ')})`\n              )\n            }\n          }\n        }\n      }\n    }\n\n    const hasInvalidKeys = invalidKeys.length > 0\n    const hasInvalidParts = invalidParts.length > 0\n\n    if (hasInvalidKeys || hasInvalidParts) {\n      console.error(\n        `${invalidParts.join(', ')}${\n          invalidKeys.length\n            ? (hasInvalidParts ? ',' : '') +\n              ` invalid field${invalidKeys.length === 1 ? '' : 's'}: ` +\n              invalidKeys.join(',')\n            : ''\n        } for route ${JSON.stringify(route)}`\n      )\n      console.error()\n      numInvalidRoutes++\n    }\n  }\n\n  if (numInvalidRoutes > 0) {\n    if (hadInvalidStatus) {\n      console.error(\n        `\\nValid redirect statusCode values are ${[...allowedStatusCodes].join(\n          ', '\n        )}`\n      )\n    }\n    if (hadInvalidHas) {\n      console.error(\n        `\\nValid \\`has\\` object shape is ${JSON.stringify(\n          {\n            type: [...allowedHasTypes].join(', '),\n            key: 'the key to check for',\n            value: 'undefined or a value string to match against',\n          },\n          null,\n          2\n        )}`\n      )\n    }\n    console.error()\n    console.error(\n      `Error: Invalid ${type}${numInvalidRoutes === 1 ? '' : 's'} found`\n    )\n    process.exit(1)\n  }\n}\n\nexport interface CustomRoutes {\n  headers: Header[]\n  rewrites: {\n    fallback: Rewrite[]\n    afterFiles: Rewrite[]\n    beforeFiles: Rewrite[]\n  }\n  redirects: Redirect[]\n}\n\nfunction processRoutes<T>(\n  routes: T,\n  config: NextConfig,\n  type: 'redirect' | 'rewrite' | 'header'\n): T {\n  const _routes = (routes as any) as Array<{\n    source: string\n    locale?: false\n    basePath?: false\n    destination?: string\n  }>\n  const newRoutes: typeof _routes = []\n  const defaultLocales: Array<{\n    locale: string\n    base: string\n  }> = []\n\n  if (config.i18n && type === 'redirect') {\n    for (const item of config.i18n?.domains || []) {\n      defaultLocales.push({\n        locale: item.defaultLocale,\n        base: `http${item.http ? '' : 's'}://${item.domain}`,\n      })\n    }\n\n    defaultLocales.push({\n      locale: config.i18n.defaultLocale,\n      base: '',\n    })\n  }\n\n  for (const r of _routes) {\n    const srcBasePath =\n      config.basePath && r.basePath !== false ? config.basePath : ''\n    const isExternal = !r.destination?.startsWith('/')\n    const destBasePath = srcBasePath && !isExternal ? srcBasePath : ''\n\n    if (config.i18n && r.locale !== false) {\n      defaultLocales.forEach((item) => {\n        let destination\n\n        if (r.destination) {\n          destination = item.base\n            ? `${item.base}${destBasePath}${r.destination}`\n            : `${destBasePath}${r.destination}`\n        }\n\n        newRoutes.push({\n          ...r,\n          destination,\n          source: `${srcBasePath}/${item.locale}${r.source}`,\n        })\n      })\n\n      r.source = `/:nextInternalLocale(${config.i18n.locales\n        .map((locale: string) => escapeStringRegexp(locale))\n        .join('|')})${\n        r.source === '/' && !config.trailingSlash ? '' : r.source\n      }`\n\n      if (r.destination && r.destination?.startsWith('/')) {\n        r.destination = `/:nextInternalLocale${\n          r.destination === '/' && !config.trailingSlash ? '' : r.destination\n        }`\n      }\n    }\n    r.source = `${srcBasePath}${\n      r.source === '/' && srcBasePath ? '' : r.source\n    }`\n\n    if (r.destination) {\n      r.destination = `${destBasePath}${\n        r.destination === '/' && destBasePath ? '' : r.destination\n      }`\n    }\n    newRoutes.push(r)\n  }\n  return (newRoutes as any) as T\n}\n\nasync function loadRedirects(config: NextConfig) {\n  if (typeof config.redirects !== 'function') {\n    return []\n  }\n  let redirects = await config.redirects()\n  checkCustomRoutes(redirects, 'redirect')\n  return processRoutes(redirects, config, 'redirect')\n}\n\nasync function loadRewrites(config: NextConfig) {\n  if (typeof config.rewrites !== 'function') {\n    return {\n      beforeFiles: [],\n      afterFiles: [],\n      fallback: [],\n    }\n  }\n  const _rewrites = await config.rewrites()\n  let beforeFiles: Rewrite[] = []\n  let afterFiles: Rewrite[] = []\n  let fallback: Rewrite[] = []\n\n  if (\n    !Array.isArray(_rewrites) &&\n    typeof _rewrites === 'object' &&\n    Object.keys(_rewrites).every(\n      (key) =>\n        key === 'beforeFiles' || key === 'afterFiles' || key === 'fallback'\n    )\n  ) {\n    beforeFiles = _rewrites.beforeFiles || []\n    afterFiles = _rewrites.afterFiles || []\n    fallback = _rewrites.fallback || []\n  } else {\n    afterFiles = _rewrites as any\n  }\n\n  checkCustomRoutes(beforeFiles, 'rewrite')\n  checkCustomRoutes(afterFiles, 'rewrite')\n  checkCustomRoutes(fallback, 'rewrite')\n\n  return {\n    beforeFiles: processRoutes(beforeFiles, config, 'rewrite'),\n    afterFiles: processRoutes(afterFiles, config, 'rewrite'),\n    fallback: processRoutes(fallback, config, 'rewrite'),\n  }\n}\n\nasync function loadHeaders(config: NextConfig) {\n  if (typeof config.headers !== 'function') {\n    return []\n  }\n  let headers = await config.headers()\n  checkCustomRoutes(headers, 'header')\n  return processRoutes(headers, config, 'header')\n}\n\nexport default async function loadCustomRoutes(\n  config: NextConfig\n): Promise<CustomRoutes> {\n  const [headers, rewrites, redirects] = await Promise.all([\n    loadHeaders(config),\n    loadRewrites(config),\n    loadRedirects(config),\n  ])\n\n  if (config.trailingSlash) {\n    redirects.unshift(\n      {\n        source: '/:file((?!\\\\.well-known(?:/.*)?)(?:[^/]+/)*[^/]+\\\\.\\\\w+)/',\n        destination: '/:file',\n        permanent: true,\n        locale: config.i18n ? false : undefined,\n        internal: true,\n      } as Redirect,\n      {\n        source: '/:notfile((?!\\\\.well-known(?:/.*)?)(?:[^/]+/)*[^/\\\\.]+)',\n        destination: '/:notfile/',\n        permanent: true,\n        locale: config.i18n ? false : undefined,\n        internal: true,\n      } as Redirect\n    )\n    if (config.basePath) {\n      redirects.unshift({\n        source: config.basePath,\n        destination: config.basePath + '/',\n        permanent: true,\n        basePath: false,\n        locale: config.i18n ? false : undefined,\n        internal: true,\n      } as Redirect)\n    }\n  } else {\n    redirects.unshift({\n      source: '/:path+/',\n      destination: '/:path+',\n      permanent: true,\n      locale: config.i18n ? false : undefined,\n      internal: true,\n    } as Redirect)\n    if (config.basePath) {\n      redirects.unshift({\n        source: config.basePath + '/',\n        destination: config.basePath,\n        permanent: true,\n        basePath: false,\n        locale: config.i18n ? false : undefined,\n        internal: true,\n      } as Redirect)\n    }\n  }\n\n  return {\n    headers,\n    rewrites,\n    redirects,\n  }\n}\n"]}