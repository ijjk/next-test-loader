{"version":3,"sources":["lib/recursive-readdir.ts"],"sourcesContent":["import { promises } from 'fs'\nimport { join } from 'path'\n\n/**\n * Recursively read directory\n * @param  {string} dir Directory to read\n * @param  {RegExp} filter Filter for the file name, only the name part is considered, not the full path\n * @param  {string[]=[]} arr This doesn't have to be provided, it's used for the recursion\n * @param  {string=dir`} rootDir Used to replace the initial path, only the relative path is left, it's faster than path.relative.\n * @returns Promise array holding all relative paths\n */\nexport async function recursiveReadDir(\n  dir: string,\n  filter: RegExp,\n  ignore?: RegExp,\n  arr: string[] = [],\n  rootDir: string = dir\n): Promise<string[]> {\n  const result = await promises.readdir(dir)\n\n  await Promise.all(\n    result.map(async (part: string) => {\n      const absolutePath = join(dir, part)\n      if (ignore && ignore.test(part)) return\n\n      const pathStat = await promises.stat(absolutePath)\n\n      if (pathStat.isDirectory()) {\n        await recursiveReadDir(absolutePath, filter, ignore, arr, rootDir)\n        return\n      }\n\n      if (!filter.test(part)) {\n        return\n      }\n\n      arr.push(absolutePath.replace(rootDir, ''))\n    })\n  )\n\n  return arr.sort()\n}\n"],"names":[],"mappings":";;;;QAWsB,gBAAgB,GAAhB,gBAAgB;AAXb,GAAI,CAAJ,GAAI;AACR,GAAM,CAAN,KAAM;eAUL,gBAAgB,CACpC,GAAW,EACX,MAAc,EACd,MAAe,EACf,GAAa,OACb,OAAe,GAAG,GAAG,EACF,CAAC;IACpB,KAAK,CAAC,MAAM,SAlBW,GAAI,UAkBG,OAAO,CAAC,GAAG;UAEnC,OAAO,CAAC,GAAG,CACf,MAAM,CAAC,GAAG,QAAQ,IAAY,GAAK,CAAC;QAClC,KAAK,CAAC,YAAY,OArBH,KAAM,OAqBK,GAAG,EAAE,IAAI;QACnC,EAAE,EAAE,MAAM,IAAI,MAAM,CAAC,IAAI,CAAC,IAAI;QAE9B,KAAK,CAAC,QAAQ,SAzBK,GAAI,UAyBS,IAAI,CAAC,YAAY;QAEjD,EAAE,EAAE,QAAQ,CAAC,WAAW,IAAI,CAAC;kBACrB,gBAAgB,CAAC,YAAY,EAAE,MAAM,EAAE,MAAM,EAAE,GAAG,EAAE,OAAO;;QAEnE,CAAC;QAED,EAAE,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,GAAG,CAAC;;QAEzB,CAAC;QAED,GAAG,CAAC,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,OAAO;IACvC,CAAC;WAGI,GAAG,CAAC,IAAI;AACjB,CAAC"}