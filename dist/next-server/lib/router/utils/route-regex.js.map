{"version":3,"sources":["../../../../../next-server/lib/router/utils/route-regex.ts"],"names":["escapeRegex","str","replace","parseParameter","param","optional","startsWith","endsWith","slice","repeat","key","getRouteRegex","normalizedRoute","segments","split","groups","groupIndex","parameterizedRoute","map","segment","pos","join","window","routeKeys","namedParameterizedRoute","cleanedKey","re","RegExp","namedRegex"],"mappings":"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","sourcesContent":["interface Group {\n  pos: number\n  repeat: boolean\n  optional: boolean\n}\n\n// this isn't importing the escape-string-regex module\n// to reduce bytes\nfunction escapeRegex(str: string) {\n  return str.replace(/[|\\\\{}()[\\]^$+*?.-]/g, '\\\\$&')\n}\n\nfunction parseParameter(param: string) {\n  const optional = param.startsWith('[') && param.endsWith(']')\n  if (optional) {\n    param = param.slice(1, -1)\n  }\n  const repeat = param.startsWith('...')\n  if (repeat) {\n    param = param.slice(3)\n  }\n  return { key: param, repeat, optional }\n}\n\nexport function getRouteRegex(\n  normalizedRoute: string\n): {\n  re: RegExp\n  namedRegex?: string\n  routeKeys?: { [named: string]: string }\n  groups: { [groupName: string]: Group }\n} {\n  const segments = (normalizedRoute.replace(/\\/$/, '') || '/')\n    .slice(1)\n    .split('/')\n\n  const groups: { [groupName: string]: Group } = {}\n  let groupIndex = 1\n  const parameterizedRoute = segments\n    .map((segment) => {\n      if (segment.startsWith('[') && segment.endsWith(']')) {\n        const { key, optional, repeat } = parseParameter(segment.slice(1, -1))\n        groups[key] = { pos: groupIndex++, repeat, optional }\n        return repeat ? (optional ? '(?:/(.+?))?' : '/(.+?)') : '/([^/]+?)'\n      } else {\n        return `/${escapeRegex(segment)}`\n      }\n    })\n    .join('')\n\n  // dead code eliminate for browser since it's only needed\n  // while generating routes-manifest\n  if (typeof window === 'undefined') {\n    const routeKeys: { [named: string]: string } = {}\n\n    let namedParameterizedRoute = segments\n      .map((segment) => {\n        if (segment.startsWith('[') && segment.endsWith(']')) {\n          const { key, optional, repeat } = parseParameter(segment.slice(1, -1))\n          // replace any non-word characters since they can break\n          // the named regex\n          const cleanedKey = key.replace(/\\W/g, '')\n          routeKeys[cleanedKey] = key\n          return repeat\n            ? optional\n              ? `(?:/(?<${cleanedKey}>.+?))?`\n              : `/(?<${cleanedKey}>.+?)`\n            : `/(?<${cleanedKey}>[^/]+?)`\n        } else {\n          return `/${escapeRegex(segment)}`\n        }\n      })\n      .join('')\n\n    return {\n      re: new RegExp(`^${parameterizedRoute}(?:/)?$`, 'i'),\n      groups,\n      routeKeys,\n      namedRegex: `^${namedParameterizedRoute}(?:/)?$`,\n    }\n  }\n\n  return {\n    re: new RegExp(`^${parameterizedRoute}(?:/)?$`, 'i'),\n    groups,\n  }\n}\n"]}