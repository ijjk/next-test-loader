{"version":3,"sources":["../../../next-server/server/send-payload.ts"],"names":["sendPayload","req","res","payload","type","generateEtags","poweredByHeader","options","setHeader","etag","undefined","sendEtagResponse","getHeader","Buffer","byteLength","private","stateful","hasHeader","revalidate","Error","end","method","headers","statusCode"],"mappings":"+GACA,mCACA,kDACA,uE,mFAEO,QAASA,CAAAA,WAAT,CACLC,GADK,CAELC,GAFK,CAGLC,OAHK,CAILC,IAJK,CAKL,CACEC,aADF,CAEEC,eAFF,CALK,CASLC,OATK,CAaC,CACN,GAAI,qBAAUL,GAAV,CAAJ,CAAoB,CAClB,OACD,CAED,GAAII,eAAe,EAAIF,IAAI,GAAK,MAAhC,CAAwC,CACtCF,GAAG,CAACM,SAAJ,CAAc,cAAd,CAA8B,SAA9B,EACD,CAED,KAAMC,CAAAA,IAAI,CAAGJ,aAAa,CAAG,kBAAaF,OAAb,CAAH,CAA2BO,SAArD,CACA,GAAIC,gBAAgB,CAACV,GAAD,CAAMC,GAAN,CAAWO,IAAX,CAApB,CAAsC,CACpC,OACD,CAED,GAAI,CAACP,GAAG,CAACU,SAAJ,CAAc,cAAd,CAAL,CAAoC,CAClCV,GAAG,CAACM,SAAJ,CACE,cADF,CAEEJ,IAAI,GAAK,MAAT,CAAkB,kBAAlB,CAAuC,0BAFzC,EAID,CACDF,GAAG,CAACM,SAAJ,CAAc,gBAAd,CAAgCK,MAAM,CAACC,UAAP,CAAkBX,OAAlB,CAAhC,EACA,GAAII,OAAO,EAAI,IAAf,CAAqB,CACnB,GAAIA,OAAO,CAACQ,OAAR,EAAmBR,OAAO,CAACS,QAA/B,CAAyC,CACvC,GAAIT,OAAO,CAACQ,OAAR,EAAmB,CAACb,GAAG,CAACe,SAAJ,CAAc,eAAd,CAAxB,CAAwD,CACtDf,GAAG,CAACM,SAAJ,CACE,eADF,CAEG,yDAFH,EAID,CACF,CAPD,IAOO,IAAI,MAAOD,CAAAA,OAAO,CAACW,UAAf,GAA8B,QAAlC,CAA4C,CACjD,GAAIX,OAAO,CAACW,UAAR,CAAqB,CAAzB,CAA4B,CAC1B,KAAM,IAAIC,CAAAA,KAAJ,CACH,uDAAsDZ,OAAO,CAACW,UAAW,MADtE,CAAN,CAGD,CAEDhB,GAAG,CAACM,SAAJ,CACE,eADF,CAEG,YAAWD,OAAO,CAACW,UAAW,0BAFjC,EAID,CAXM,IAWA,IAAIX,OAAO,CAACW,UAAR,GAAuB,KAA3B,CAAkC,CACvChB,GAAG,CAACM,SAAJ,CACE,eADF,CAEG,2CAFH,EAID,CACF,CACDN,GAAG,CAACkB,GAAJ,CAAQnB,GAAG,CAACoB,MAAJ,GAAe,MAAf,CAAwB,IAAxB,CAA+BlB,OAAvC,EACD,CAEM,QAASQ,CAAAA,gBAAT,CACLV,GADK,CAELC,GAFK,CAGLO,IAHK,CAII,CACT,GAAIA,IAAJ,CAAU,CACR;AACJ;AACA;AACA;AACA;AACA,OACIP,GAAG,CAACM,SAAJ,CAAc,MAAd,CAAsBC,IAAtB,EACD,CAED,GAAI,mBAAMR,GAAG,CAACqB,OAAV,CAAmB,CAAEb,IAAF,CAAnB,CAAJ,CAAkC,CAChCP,GAAG,CAACqB,UAAJ,CAAiB,GAAjB,CACArB,GAAG,CAACkB,GAAJ,GACA,MAAO,KAAP,CACD,CAED,MAAO,MAAP,CACD","sourcesContent":["import { IncomingMessage, ServerResponse } from 'http'\nimport { isResSent } from '../lib/utils'\nimport generateETag from 'etag'\nimport fresh from 'next/dist/compiled/fresh'\n\nexport function sendPayload(\n  req: IncomingMessage,\n  res: ServerResponse,\n  payload: any,\n  type: 'html' | 'json',\n  {\n    generateEtags,\n    poweredByHeader,\n  }: { generateEtags: boolean; poweredByHeader: boolean },\n  options?:\n    | { private: true }\n    | { private: boolean; stateful: true }\n    | { private: boolean; stateful: false; revalidate: number | false }\n): void {\n  if (isResSent(res)) {\n    return\n  }\n\n  if (poweredByHeader && type === 'html') {\n    res.setHeader('X-Powered-By', 'Next.js')\n  }\n\n  const etag = generateEtags ? generateETag(payload) : undefined\n  if (sendEtagResponse(req, res, etag)) {\n    return\n  }\n\n  if (!res.getHeader('Content-Type')) {\n    res.setHeader(\n      'Content-Type',\n      type === 'json' ? 'application/json' : 'text/html; charset=utf-8'\n    )\n  }\n  res.setHeader('Content-Length', Buffer.byteLength(payload))\n  if (options != null) {\n    if (options.private || options.stateful) {\n      if (options.private || !res.hasHeader('Cache-Control')) {\n        res.setHeader(\n          'Cache-Control',\n          `private, no-cache, no-store, max-age=0, must-revalidate`\n        )\n      }\n    } else if (typeof options.revalidate === 'number') {\n      if (options.revalidate < 1) {\n        throw new Error(\n          `invariant: invalid Cache-Control duration provided: ${options.revalidate} < 1`\n        )\n      }\n\n      res.setHeader(\n        'Cache-Control',\n        `s-maxage=${options.revalidate}, stale-while-revalidate`\n      )\n    } else if (options.revalidate === false) {\n      res.setHeader(\n        'Cache-Control',\n        `s-maxage=31536000, stale-while-revalidate`\n      )\n    }\n  }\n  res.end(req.method === 'HEAD' ? null : payload)\n}\n\nexport function sendEtagResponse(\n  req: IncomingMessage,\n  res: ServerResponse,\n  etag: string | undefined\n): boolean {\n  if (etag) {\n    /**\n     * The server generating a 304 response MUST generate any of the\n     * following header fields that would have been sent in a 200 (OK)\n     * response to the same request: Cache-Control, Content-Location, Date,\n     * ETag, Expires, and Vary. https://tools.ietf.org/html/rfc7232#section-4.1\n     */\n    res.setHeader('ETag', etag)\n  }\n\n  if (fresh(req.headers, { etag })) {\n    res.statusCode = 304\n    res.end()\n    return true\n  }\n\n  return false\n}\n"]}