{"version":3,"sources":["../../../../../shared/lib/router/utils/route-matcher.ts"],"names":["getRouteMatcher","routeRegex","re","groups","pathname","routeMatch","exec","decode","param","decodeURIComponent","_","DecodeError","params","Object","keys","forEach","slugName","g","m","pos","undefined","indexOf","split","map","entry","repeat"],"mappings":"6EAAA,kCAGO,QAASA,CAAAA,eAAT,CAAyBC,UAAzB,CAAuE,CAC5E,KAAM,CAAEC,EAAF,CAAMC,MAAN,EAAiBF,UAAvB,CACA,MAAQG,CAAAA,QAAD,EAAyC,CAC9C,KAAMC,CAAAA,UAAU,CAAGH,EAAE,CAACI,IAAH,CAAQF,QAAR,CAAnB,CACA,GAAI,CAACC,UAAL,CAAiB,CACf,MAAO,MAAP,CACD,CAED,KAAME,CAAAA,MAAM,CAAIC,KAAD,EAAmB,CAChC,GAAI,CACF,MAAOC,CAAAA,kBAAkB,CAACD,KAAD,CAAzB,CACD,CAAC,MAAOE,CAAP,CAAU,CACV,KAAM,IAAIC,mBAAJ,CAAgB,wBAAhB,CAAN,CACD,CACF,CAND,CAOA,KAAMC,CAAAA,MAAkD,CAAG,EAA3D,CAEAC,MAAM,CAACC,IAAP,CAAYX,MAAZ,EAAoBY,OAApB,CAA6BC,QAAD,EAAsB,CAChD,KAAMC,CAAAA,CAAC,CAAGd,MAAM,CAACa,QAAD,CAAhB,CACA,KAAME,CAAAA,CAAC,CAAGb,UAAU,CAACY,CAAC,CAACE,GAAH,CAApB,CACA,GAAID,CAAC,GAAKE,SAAV,CAAqB,CACnBR,MAAM,CAACI,QAAD,CAAN,CAAmB,CAACE,CAAC,CAACG,OAAF,CAAU,GAAV,CAAD,CACfH,CAAC,CAACI,KAAF,CAAQ,GAAR,EAAaC,GAAb,CAAkBC,KAAD,EAAWjB,MAAM,CAACiB,KAAD,CAAlC,CADe,CAEfP,CAAC,CAACQ,MAAF,CACA,CAAClB,MAAM,CAACW,CAAD,CAAP,CADA,CAEAX,MAAM,CAACW,CAAD,CAJV,CAKD,CACF,CAVD,EAWA,MAAON,CAAAA,MAAP,CACD,CA3BD,CA4BD","sourcesContent":["import { DecodeError } from '../../utils'\nimport { getRouteRegex } from './route-regex'\n\nexport function getRouteMatcher(routeRegex: ReturnType<typeof getRouteRegex>) {\n  const { re, groups } = routeRegex\n  return (pathname: string | null | undefined) => {\n    const routeMatch = re.exec(pathname!)\n    if (!routeMatch) {\n      return false\n    }\n\n    const decode = (param: string) => {\n      try {\n        return decodeURIComponent(param)\n      } catch (_) {\n        throw new DecodeError('failed to decode param')\n      }\n    }\n    const params: { [paramName: string]: string | string[] } = {}\n\n    Object.keys(groups).forEach((slugName: string) => {\n      const g = groups[slugName]\n      const m = routeMatch[g.pos]\n      if (m !== undefined) {\n        params[slugName] = ~m.indexOf('/')\n          ? m.split('/').map((entry) => decode(entry))\n          : g.repeat\n          ? [decode(m)]\n          : decode(m)\n      }\n    })\n    return params\n  }\n}\n"]}